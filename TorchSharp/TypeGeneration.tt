<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
using System;
using System.Linq;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using Microsoft.Win32.SafeHandles;
using System.Text;

namespace TorchSharp {
<#
foreach (var type in new [] { 
    new { ApiName = "Byte", Storage = "byte", AccReal="long" }, 
    new { ApiName = "Short", Storage = "short", AccReal="long" },   
    new { ApiName = "Int", Storage = "int",  AccReal="long"},
    new { ApiName = "Long", Storage = "long", AccReal="long" },
    new { ApiName = "Double", Storage = "double", AccReal="double" },
    new { ApiName = "Float", Storage = "float", AccReal="double" },
     }){
        string tname = type.ApiName;
        string ttype = type.Storage;
        string accreal = type.AccReal;
        
        // In the future, we should add HalfFloat (16-bit float)
        bool isFloat = type.Storage == "double" || type.Storage == "float";
        bool isByte = type.Storage == "byte";
#>
    public partial class <#=tname#>Tensor : IDisposable {
        /// <summary>
        ///    The storage class provides a mechanism to access the underlying data representation for tensors.
        /// </summary>
        public class <#=tname#>Storage : IDisposable {
            internal sealed class HType : SafeHandle {
                public HType (IntPtr preexistingHandle, bool ownsHandle) : base (IntPtr.Zero, ownsHandle)
                {
                    SetHandle (preexistingHandle);
                }
                
                public override bool IsInvalid => handle == (IntPtr) 0;
                // This is just for marshalling
                internal HType () : base (IntPtr.Zero, true)
                {
                }
                
                [DllImport ("caffe2")]
                extern static void TH<#=tname#>Storage_free (IntPtr handle);
            
                
                protected override bool ReleaseHandle ()
                {
                    TH<#=tname#>Storage_free (handle);
                    handle = IntPtr.Zero;
                    return true;
                }
            }

            internal HType handle;
            
            [DllImport ("caffe2")]
            extern static HType TH<#=tname#>Storage_new ();
            
            /// <summary>
            ///   Initializes an empty <#=tname#>Storage instance.
            /// </summary>
            public <#=tname#>Storage ()
            {
                handle = TH<#=tname#>Storage_new ();
            }
            
            internal <#=tname#>Storage (HType fromHandle)
            {
                this.handle = fromHandle;
            }
            
            [DllImport ("caffe2")]
            extern static HType TH<#=tname#>Storage_new_withSize (IntPtr size);
            
            /// <summary>
            ///   Initializes a <#=tname#>Storage instance with the specified size.
            /// </summary>        
            /// <param name="size">The desired number of elements in the storage</param>
            public <#=tname#>Storage (long size)
            {
                handle = TH<#=tname#>Storage_new_withSize ((IntPtr) size);
            }
            
            /// <summary>
            /// Finalizer
            /// </summary>
            ~<#=tname#>Storage ()
            {
                Dispose (false);
            }
            
            /// <summary>
            ///   Releases the storage.
            /// </summary>        
            public void Dispose ()
            {
                Dispose (true);
                GC.SuppressFinalize (this);
            }
            
            /// <summary>
            ///   Implements the .NET Dispose pattern.
            /// </summary>
            protected void Dispose (bool disposing)
            {
                if (disposing){
                    handle.Dispose ();
                    handle = null;
                }
            }
            
            [DllImport ("caffe2")]
            extern static <#=ttype#> TH<#=tname#>Storage_get (HType handle, /*ptrdiff_t*/IntPtr pos);
            [DllImport ("caffe2")]
            extern static void TH<#=tname#>Storage_set (HType handle, /*ptrdiff_t*/IntPtr pos,  <#=ttype#> value);
            
            /// <summary>
            /// </summary>
            public <#=ttype#> this [long index] {
                get => TH<#=tname#>Storage_get (handle, (IntPtr) (index));
                set {
                    TH<#=tname#>Storage_set (handle, (IntPtr) (index), value);
                }
            }
            
            [DllImport ("caffe2")]
            extern static <#=ttype#> TH<#=tname#>Storage_resize (HType handle, /*ptrdiff_t*/UIntPtr newSize);
            
            /// <summary>
            ///   Changes the size of this storage to the new requested size.
            /// </summary>
            /// <param name="size">The desired new size.</param>
            public void Resize (ulong size)
            {
                TH<#=tname#>Storage_resize (handle, (UIntPtr) size);
            }

            [DllImport ("caffe2")]
            extern static void TH<#=tname#>Storage_fill (HType handle, <#=ttype#> value);
            
            /// <summary>
            ///   Fills every element of the storage with the specified value.
            /// </summary>
            /// <param name="value">Value used for each element</param>
            public void Fill (<#=ttype#> value)
            {
                TH<#=tname#>Storage_fill (handle, value);
            }
        }
    }
    
    /// <summary>
    ///   Tensor of type <#=tname#>.
    /// </summary>
    /// <remarks>
    ///   <para>
    ///     Use the default constructor to create an empty tensor, or invoke one of the
    ///     constructors with one (1D), two (2D), three (3D), or four parameters (4D) to x
    ///     create a tensor for the desired number of dimensions.
    ///   </para>
    /// </remarks>
    public partial class <#=tname#>Tensor : IDisposable {
        internal sealed class HType : SafeHandle {
            public HType (IntPtr preexistingHandle, bool ownsHandle) : base (IntPtr.Zero, ownsHandle)
            {
                SetHandle (preexistingHandle);
            }

            // This is just for marshalling
            internal HType () : base (IntPtr.Zero, true)
            {
            }
                
            public override bool IsInvalid => handle == (IntPtr) 0;

            [DllImport ("caffe2")]
            extern static void TH<#=tname#>Tensor_free (IntPtr handle);
                
            protected override bool ReleaseHandle ()
            {
                TH<#=tname#>Tensor_free (handle);
                handle = IntPtr.Zero;
                return true;
            }
        }
        internal HType handle;
        
        [DllImport ("caffe2")]
        extern static HType TH<#=tname#>Tensor_new ();
        
        /// <summary>
        ///    Creates an empty tensor.
        /// </summary>
        public <#=tname#>Tensor ()
        {
            handle = TH<#=tname#>Tensor_new ();
        }

        internal <#=tname#>Tensor (HType handle)
        {
            this.handle = handle;
        }

        [DllImport ("caffe2")]
        extern static HType TH<#=tname#>Tensor_newWithSize1d (long size0);

        /// <summary>
        ///    Creates a 1D tensor of the specified size.
        /// </summary>    
        /// <param name="size0">Size for the first dimension.</param>
        public <#=tname#>Tensor (long size0)
        {
            handle = TH<#=tname#>Tensor_newWithSize1d (size0);
        }

        [DllImport ("caffe2")]
        extern static HType TH<#=tname#>Tensor_newWithSize2d (long size0, long size1);
        
        /// <summary>
        ///    Creates a 2D tensor of the specified size.
        /// </summary>        
        /// <param name="size0">Size for the first dimension.</param>
        /// <param name="size1">Size for the second dimension.</param>
        public <#=tname#>Tensor (long size0, long size1)
        {
            handle = TH<#=tname#>Tensor_newWithSize2d (size0, size1);
        }

        [DllImport ("caffe2")]
        extern static HType TH<#=tname#>Tensor_newWithSize3d (long size0, long size1, long size2);

        /// <summary>
        ///    Creates a 3D tensor of the specified size.
        /// </summary>        
        /// <param name="size0">Size for the first dimension.</param>
        /// <param name="size1">Size for the second dimension.</param>
        /// <param name="size2">Size for the third dimension.</param>
        public <#=tname#>Tensor (long size0, long size1, long size2)
        {
            handle = TH<#=tname#>Tensor_newWithSize3d (size0, size1, size2);
        }

        [DllImport ("caffe2")]
        extern static HType TH<#=tname#>Tensor_newWithSize4d (long size0, long size1, long size2, long size3);
        
        /// <summary>
        ///    Creates a 4D tensor of the specified size.
        /// </summary>
        /// <param name="size0">Size for the first dimension.</param>
        /// <param name="size1">Size for the second dimension.</param>
        /// <param name="size2">Size for the third dimension.</param>
        /// <param name="size3">Size for the fourth dimension.</param>
        public <#=tname#>Tensor (long size0, long size1, long size2, long size3)
        {
            handle = TH<#=tname#>Tensor_newWithSize4d (size0, size1, size2, size3);
        }
        
        /// <summary>
        ///  Finalizer for ~<#=tname#>Tensor
        /// </summary>
        ~<#=tname#>Tensor ()
        {
            Dispose (false);
        }
        
        /// <summary>
        ///   Releases the tensor and its associated data.
        /// </summary>        
        public void Dispose ()
        {
            Dispose (true);
            GC.SuppressFinalize (this);
        }
        
        /// <summary>
        ///   Implements the .NET Dispose pattern.
        /// </summary>
        protected void Dispose (bool disposing)
        {
            if (disposing) {
                handle.Dispose ();
                handle = null;
            }
        }

        [DllImport ("caffe2")]
        extern static long TH<#=tname#>Tensor_numel (HType handle);
     
        /// <summary>
        ///  Get the number of elements in the tensor.
        /// </summary>
        public long NumElements ()
        {
            return TH<#=tname#>Tensor_numel (handle);
        }   

        
        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_zero (HType handle);
     
        /// <summary>
        ///  Fills the tensor with zeros
        /// </summary>
        public void ZeroFill ()
        {
            TH<#=tname#>Tensor_zero (handle);
        }   
        
        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_fill (HType handle, <#=ttype#> value);
        
        /// <summary>
        ///  Fills the tensor with the specified value
        /// </summary>
        public void Fill (<#=ttype#> value)
        {
            TH<#=tname#>Tensor_fill (handle, value);
        }
        
        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_nonzero (LongTensor.HType subscript, HType handle);
     
        /// <summary>
        ///  Finds the indices of all non-zero elements.
        /// </summary>
        public LongTensor NonZero ()
        {
            var result = new LongTensor();
            TH<#=tname#>Tensor_nonzero (result.handle, this.handle);
            return result;
        }   
        
        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_maskedFill (HType handle1, ByteTensor.HType handle2, <#=ttype#> value);
        
        /// <summary>
        ///  Fills the tensor with the specified value at the locations indicated by the mask.
        /// </summary>
        /// <param name="mask">A byte tensor with values 0 or 1 indicating the locations where the value should be filled.</param>
        /// <param name="value">The value to write at the indicated locations.</param>
        public void MaskedFill (ByteTensor mask, <#=ttype#> value)
        {
            TH<#=tname#>Tensor_maskedFill (handle, mask.handle, value);
        }

        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_maskedCopy (HType handle1, ByteTensor.HType handle2, HType src);
        
        /// <summary>
        ///  Copies elements from the source tensor to the locations indicated by the mask.
        /// </summary>
        /// <param name="mask">A byte tensor with values 0 or 1 indicating the locations where in the destination the value should be filled.</param>
        /// <param name="src">The source tensor.</param>
        /// <remarks>
        ///  There must be at least as many elements in the source tensor as there are 1s in the mask.
        /// </remarks>
        public void MaskedCopy (ByteTensor mask, <#=tname#>Tensor src)
        {
            TH<#=tname#>Tensor_maskedCopy (handle, mask.handle, src.handle);
        }

        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_maskedSelect (HType handle1, HType src, ByteTensor.HType handle2);
        
        /// <summary>
        ///  Copies elements from the source tensor at the locations indicated by the mask.
        /// </summary>
        /// <param name="mask">A byte tensor with values 0 or 1 indicating the locations where in the source the value should be fetched.</param>
        /// <param name="src">The source tensor.</param>
        /// <remarks>
        ///  There will be as many elements in the tensor as there are 1s in the mask.
        ///  There must be at least as many elements in the source tensor as there are 1s in the mask.
        /// </remarks>
        public void MaskedSelect (ByteTensor mask, <#=tname#>Tensor src)
        {
            TH<#=tname#>Tensor_maskedSelect (handle, src.handle, mask.handle);
        }

        [DllImport ("caffe2")]
        extern static <#=tname#>Storage.HType TH<#=tname#>Tensor_storage (HType handle);

        /// <summary>
        ///  Returns the associated storage for this tensor
        /// </summary>
        
        public <#=tname#>Storage Storage => new <#=tname#>Storage (TH<#=tname#>Tensor_storage (handle));
        
        [DllImport ("caffe2")]
        extern static int TH<#=tname#>Tensor_nDimension (HType handle);
        
        /// <summary>
        ///  Returns the number of dimensions for this tensor
        /// </summary>
        public int Dimensions => TH<#=tname#>Tensor_nDimension (handle);
        
        [DllImport ("caffe2")]
        extern static long TH<#=tname#>Tensor_size (HType handle, int dim);
        
        /// <summary>
        ///  Retrieves the size of the specified dimension in the tensor.
        /// </summary>
        public long GetTensorDimension (int dim)
        {
            return TH<#=tname#>Tensor_size (handle, dim);
        }

        /// <summary>
        /// Returns the tensor shape, this is an array whose size determines the number of dimensions on the tensor, and each element is the size of the dimension
        /// </summary>
        /// <remarks>
        ///     An array of size 0 is used for constants, an array of size 1 is used
        ///     for single-dimension arrays, where the dimension is the value of the
        ///     first element.   And so on.
        /// </remarks>
        public long [] Shape {
            get {
                    var dims = new long [Dimensions];
                    for (int i = 0; i < dims.Length; i++)
                            dims [i] = (long)GetTensorDimension (i);

                    return dims;
            }
        }

        [DllImport ("caffe2")]
        extern static long TH<#=tname#>Tensor_stride (HType handle, int dim);
        
        /// <summary>
        ///  Retrieves the stride of the specified dimension in the tensor.
        /// </summary>
        public long GetTensorStride (int dim)
        {
            return TH<#=tname#>Tensor_stride (handle, dim);
        }
        
        [DllImport ("caffe2")]
        extern static IntPtr TH<#=tname#>Tensor_data (HType handle);
        
        /// <summary>
        ///  Returns a pointer to the unmanaged data managed by this tensor.
        /// </summary>
        public unsafe <#=ttype#> *Data => (<#=ttype#>*) TH<#=tname#>Tensor_data (handle);
        
        [DllImport ("caffe2")]
        extern static HType TH<#=tname#>Tensor_newClone (HType handle);
        
        /// <summary>
        ///   Returns a deep clone of the tensor
        /// </summary>
        public <#=tname#>Tensor Clone () => new <#=tname#>Tensor (TH<#=tname#>Tensor_newClone (handle));
        
        [DllImport ("caffe2")]
        extern static HType TH<#=tname#>Tensor_newSelect (HType handle, int dim, long slideIndex);
        
        /// <summary>
        ///   Returns a new Tensor which is a tensor slice at the given index in the dimension dim. 
        /// </summary>
        /// <remarks>
        ///   The returned tensor has one less dimension: the dimension dim is removed. As a result, it is not possible to select() on a 1D tensor.
        /// </remarks>
        /// <param name="dim">Dimension to select</param>
        /// <param name="slideIndex">Beginning of the tensor slice</param>
        public <#=tname#>Tensor Select (int dim, long slideIndex) => new <#=tname#>Tensor (TH<#=tname#>Tensor_newSelect (handle, dim, slideIndex));

        [DllImport ("caffe2")]
        extern static HType TH<#=tname#>Tensor_newNarrow (HType handle, int dim, long firstIndex, long size);
        
        /// <summary>
        /// Returns a new Tensor which is a narrowed version of the current one: the dimension dim is narrowed from firstIndexto firstIndex+size-1.
        /// </summary>
        /// <param name="dim">The dimension to narrow</param>
        /// <param name="firstIndex">Initial index to narrow</param>
        /// <param name="size">Number of elements</param>
        public <#=tname#>Tensor Narrow (int dim, long firstIndex, long size) => new <#=tname#>Tensor (TH<#=tname#>Tensor_newNarrow (handle, dim, firstIndex, size));
                
        [DllImport ("caffe2")]
        extern static HType TH<#=tname#>Tensor_newTranspose (HType handle, int dim1, int dim2);
        
        /// <summary>
        /// Returns a tensor where dimensions dim1 and dim2 have been swapped. 
        /// </summary>
        /// <param name="dim1">First dimension</param>
        /// <param name="dim2">Second dimension</param>
        public <#=tname#>Tensor Transpose (int dim1, int dim2) => new <#=tname#>Tensor (TH<#=tname#>Tensor_newTranspose (handle, dim1, dim2));
        
        [DllImport ("caffe2")]
        extern static HType TH<#=tname#>Tensor_newUnfold (HType handle, int dim1, long size, long step);
        
        /// <summary>
        ///   Returns a tensor which contains all slices of size size in the dimension dim. Step between two slices is given by step.
        /// </summary>
        /// <param name="dim"></param>
        /// <param name="size"></param>
        /// <param name="step"></param>
        public <#=tname#>Tensor Unfold (int dim, long size, long step) => new <#=tname#>Tensor (TH<#=tname#>Tensor_newUnfold (handle, dim, size, step));
        
        [DllImport("caffe2")]
        extern static HType TH<#=tname#>Tensor_newWithStorage1d(<#=tname#>Storage.HType handle, IntPtr offset, long size, long stride);

        /// <summary>
        ///   Access to element at the specified position in the tensor
        /// </summary>        
        /// <param name="offset">Offset within the input storage the storage of the new tensor will start from.</param> 
        /// <param name="size">Size of the first dimension.</param>     
        /// <param name="stride">Stride of the first dimension.</param>          
        public <#=tname#>Tensor NewWithStorage1d(IntPtr offset, long size, long stride)
        {
            return new <#=tname#>Tensor(TH<#=tname#>Tensor_newWithStorage1d(Storage.handle, offset, size, stride));
        }

        [DllImport("caffe2")]
        extern static HType TH<#=tname#>Tensor_newWithStorage2d(<#=tname#>Storage.HType handle, IntPtr offset, long size0, long stride0, long size1, long stride1);

        /// <summary>
        ///   Access to element at the specified position in the tensor
        /// </summary>        
        /// <param name="offset">Offset within the input storage the storage of the new tensor will start from.</param> 
        /// <param name="size0">Size of the first dimension.</param>     
        /// <param name="stride0">Stride of the first dimension.</param>
        /// <param name="size1">Size of the second dimension.</param>     
        /// <param name="stride1">Stride of the second dimension.</param>
        public <#=tname#>Tensor NewWithStorage2d(IntPtr offset, long size0, long stride0, long size1, long stride1)
        {
            return new <#=tname#>Tensor(TH<#=tname#>Tensor_newWithStorage2d(Storage.handle, offset, size0, stride0, size1, stride1));
        }

        [DllImport("caffe2")]
        extern static HType TH<#=tname#>Tensor_newWithStorage3d(<#=tname#>Storage.HType handle, IntPtr offset, long size0, long stride0, long size1, long stride1, long size2, long stride2);

        /// <summary>
        ///   Access to element at the specified position in the tensor
        /// </summary>        
        /// <param name="offset">Offset within the input storage the storage of the new tensor will start from.</param> 
        /// <param name="size0">Size of the first dimension.</param>     
        /// <param name="stride0">Stride of the first dimension.</param>
        /// <param name="size1">Size of the second dimension.</param>     
        /// <param name="stride1">Stride of the second dimension.</param>
        /// <param name="size2">Size of the third dimension.</param>     
        /// <param name="stride2">Stride of the third dimension.</param>
        public <#=tname#>Tensor NewWithStorage3d(IntPtr offset, long size0, long stride0, long size1, long stride1, long size2, long stride2)
        {
            return new <#=tname#>Tensor(TH<#=tname#>Tensor_newWithStorage3d(Storage.handle, offset, size0, stride0, size1, stride1, size2, stride2));
        }

        [DllImport("caffe2")]
        extern static HType TH<#=tname#>Tensor_newWithStorage4d(<#=tname#>Storage.HType handle, IntPtr offset, long size0, long stride0, long size1, long stride1, long size2, long stride2, long size3, long stride3);

        /// <summary>
        ///   Access to element at the specified position in the tensor
        /// </summary>        
        /// <param name="offset">Offset within the input storage the storage of the new tensor will start from.</param> 
        /// <param name="size0">Size of the first dimension.</param>     
        /// <param name="stride0">Stride of the first dimension.</param>
        /// <param name="size1">Size of the second dimension.</param>     
        /// <param name="stride1">Stride of the second dimension.</param>
        /// <param name="size2">Size of the third dimension.</param>     
        /// <param name="stride2">Stride of the third dimension.</param>
        /// <param name="size3">Size of the fourth dimension.</param>     
        /// <param name="stride3">Stride of the fourth dimension.</param>
        public <#=tname#>Tensor NewWithStorage4d(IntPtr offset, long size0, long stride0, long size1, long stride1, long size2, long stride2, long size3, long stride3)
        {
            return new <#=tname#>Tensor(TH<#=tname#>Tensor_newWithStorage4d(Storage.handle, offset, size0, stride0, size1, stride1, size2, stride2, size3, stride3));
        }

        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_squeeze (HType handle, HType src);
        
        /// <summary>
        ///   Squeeze the tensor, i.e. remove all 1-sized dimensions.   
        /// </summary>
        public void Squeeze ()
        {
            TH<#=tname#>Tensor_squeeze (handle, handle);
        }
        
        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_squeeze1d (HType handle, HType src, int dimension);
        
        /// <summary>
        ///   Squeeze the tensor, by removing the specified dimension.   
        /// </summary>
        /// <param name="src">The source tensor which contains the data.</param>
        /// <param name="dimension">The dimension to squeeze.</param>
        public void Squeeze1d (<#=tname#>Tensor src, int dimension)
        {
            TH<#=tname#>Tensor_squeeze1d (handle, src.handle, dimension);
        }

        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_unsqueeze1d (HType handle, HType src, int dimension);
        
        /// <summary>
        ///   Unsqueeze the tensor, by inserting the specified dimension of size 1.   
        /// </summary>
        /// <param name="src">The source tensor which contains the data.</param>
        /// <param name="dimension">The dimension to insert.</param>
        public void Unsqueeze1d (<#=tname#>Tensor src, int dimension)
        {
            TH<#=tname#>Tensor_unsqueeze1d (handle, src.handle, dimension);
        }

        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_resize1d (HType handle, long size);
        
        /// <summary>
        ///   Resizes the tensor to be one dimensional with the specified size, the contents of the tensor after this are undetermined.
        /// </summary>
        /// <param name="size">The desired new size for the first dimension of the tensor.</param>
        public void Resize1d (long size)
        {
            TH<#=tname#>Tensor_resize1d (handle, size);
        }
        
        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_resize2d (HType handle, long size0, long size1);
        /// <summary>
        ///   Resizes the tensor to be two dimensional with the specified size, the contents of the tensor after this are undetermined.
        /// </summary>
        /// <param name="size0">The desired new size for the first dimension of the tensor.</param>
        /// <param name="size1">The desired new size for the second dimension of the tensor.</param>
        public void Resize2d (long size0, long size1)
        {
            TH<#=tname#>Tensor_resize2d (handle, size0, size1);
        }
        
        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_resize3d (HType handle, long size0, long size1, long size2);
        
        /// <summary>
        ///   Resizes the tensor to be three dimensional with the specified size, the contents of the tensor after this are undetermined.
        /// </summary>
        /// <param name="size0">The desired new size for the first dimension of the tensor.</param>
        /// <param name="size1">The desired new size for the second dimension of the tensor.</param>
        /// <param name="size2">The desired new size for the third dimension of the tensor.</param>
        public void Resize3d (long size0, long size1, long size2)
        {
            TH<#=tname#>Tensor_resize3d (handle, size0, size1, size2);
        }

        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_resize4d (HType handle, long size0, long size1, long size2, long size4);
        /// <summary>
        ///   Resizes the tensor to be four dimensional with the specified size, the contents of the tensor after this are undetermined.
        /// </summary>
        /// <param name="size0">The desired new size for the first dimension of the tensor.</param>
        /// <param name="size1">The desired new size for the second dimension of the tensor.</param>
        /// <param name="size2">The desired new size for the third dimension of the tensor.</param>
        /// <param name="size3">The desired new size for the fourth dimension of the tensor.</param>
        public void Resize4d (long size0, long size1, long size2, long size3)
        {
            TH<#=tname#>Tensor_resize4d (handle, size0, size1, size2, size3);
        }
        
        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_resize5d (HType handle, long size0, long size1, long size2, long size4, long size5);

        /// <summary>
        ///   Resizes the tensor to be five dimensional with the specified size, the contents of the tensor after this are undetermined.
        /// </summary>
        /// <param name="size0">The desired new size for the first dimension of the tensor.</param>
        /// <param name="size1">The desired new size for the second dimension of the tensor.</param>
        /// <param name="size2">The desired new size for the third dimension of the tensor.</param>
        /// <param name="size3">The desired new size for the fourth dimension of the tensor.</param>
        /// <param name="size4">The desired new size for the fifth dimension of the tensor.</param>
        public void Resize5d (long size0, long size1, long size2, long size3, long size4)
        {
            TH<#=tname#>Tensor_resize5d (handle, size0, size1, size2, size3, size4);
        }
        
        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_resizeAs (HType handle, HType src);
       
        /// <summary>
        ///   Resizes the tensor to match the dimensions of the specified src tensor, the contents of the tensor after this are undetermined.
        /// </summary>
        /// <param name="src">The source tensor whose shape will be mirrored by this tensor.</param>
        public void ResizeAs (<#=tname#>Tensor src)
        {
            TH<#=tname#>Tensor_resizeAs (handle, src.handle);
        }
        
        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_set (HType handle, HType src);
        
        /// <summary>
        ///   The tensor will use the same storage as the provided source, so any changes to that tensor are visible on this one.   
        /// </summary>
        /// <param name="src">The source tensor which contains the data..</param>
        public void Set (<#=tname#>Tensor src)
        {
            TH<#=tname#>Tensor_set (handle, src.handle);
        }
        
        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_set1d (HType handle, long x0, <#=ttype#> value);
        [DllImport ("caffe2")]
        extern static <#=ttype#> TH<#=tname#>Tensor_get1d (HType handle, long x0);

        /// <summary>
        ///   Access to element at the specified position in the tensor
        /// </summary>       
        /// <param name="x0">Index to access.</param> 
        public <#=ttype#> this [long x0] {
            get => TH<#=tname#>Tensor_get1d (handle, x0);
            set => TH<#=tname#>Tensor_set1d (handle, x0, value);
        }
        
        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_set2d (HType handle, long x0, long x1, <#=ttype#> value);
        [DllImport ("caffe2")]
        extern static <#=ttype#> TH<#=tname#>Tensor_get2d (HType handle, long x0, long x1);

        /// <summary>
        ///   Access to element at the specified position in the tensor
        /// </summary>    
        /// <param name="x0">Index in the first dimension to access.</param> 
        /// <param name="x1">Index in the second dimension to access.</param>     
        public <#=ttype#> this [long x0, long x1] {
            get => TH<#=tname#>Tensor_get2d (handle, x0, x1);
            set => TH<#=tname#>Tensor_set2d (handle, x0, x1, value);
        }

        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_set3d (HType handle, long x0, long x1, long x2, <#=ttype#> value);
        [DllImport ("caffe2")]
        extern static <#=ttype#> TH<#=tname#>Tensor_get3d (HType handle, long x0, long x1, long x2);

        /// <summary>
        ///   Access to element at the specified position in the tensor
        /// </summary>        
        /// <param name="x0">Index in the first dimension to access.</param> 
        /// <param name="x1">Index in the second dimension to access.</param>     
        /// <param name="x2">Index in the third dimension to access.</param>     
        public <#=ttype#> this [long x0, long x1, long x2] {
            get => TH<#=tname#>Tensor_get3d (handle, x0, x1, x2);
            set => TH<#=tname#>Tensor_set3d (handle, x0, x1, x2, value);
        }
        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_set4d (HType handle, long x0, long x1, long x2, long x3, <#=ttype#> value);
        [DllImport ("caffe2")]
        extern static <#=ttype#> TH<#=tname#>Tensor_get4d (HType handle, long x0, long x1, long x2, long x3);

        /// <summary>
        ///   Access to element at the specified position in the tensor
        /// </summary>        
        /// <param name="x0">Index in the first dimension to access.</param> 
        /// <param name="x1">Index in the second dimension to access.</param>     
        /// <param name="x2">Index in the third dimension to access.</param>     
        /// <param name="x3">Index in the fourth dimension to access.</param>     
        public <#=ttype#> this [long x0, long x1, long x2, long x3] {
            get => TH<#=tname#>Tensor_get4d (handle, x0, x1, x2, x3);
            set => TH<#=tname#>Tensor_set4d (handle, x0, x1, x2, x3, value);
        }
        
        [DllImport ("caffe2")]
        extern static <#=ttype#> TH<#=tname#>Tensor_random (HType handle, IntPtr thgenerator);
        
        /// <summary>
        ///  Populates the tensor with random values using the provided random source generator.
        /// </summary>
        /// <param name="source">The random generator source</param>
        public void Random (RandomGenerator source)
        {
            if (source == null)
                throw new ArgumentNullException (nameof (source));
            TH<#=tname#>Tensor_random (handle, source.handle);
        }

        [DllImport ("caffe2")]
        extern static <#=ttype#> TH<#=tname#>Tensor_clampedRandom (HType handle, IntPtr thgenerator, long min, long max);
        
        /// <summary>
        ///  Populates the tensor with random values from min to max, using the provided random source generator.
        /// </summary>
        /// <param name="source">The random generator source</param>
        /// <param name="min">The lower limit for the values to be generated</param>
        /// <param name="max">The upper limit for the values to be generated</param>
        public void ClampedRandom (RandomGenerator source, long min, long max)
        {
            if (source == null)
                throw new ArgumentNullException (nameof (source));
            TH<#=tname#>Tensor_clampedRandom (handle, source.handle, min, max);
        }

        [DllImport ("caffe2")]
        extern static <#=ttype#> TH<#=tname#>Tensor_cappedRandom (HType handle, IntPtr thgenerator, long max);
        
        /// <summary>
        ///  Populates the tensor with random values from 0 to max, using the provided random source generator.
        /// </summary>
        /// <param name="source">The random generator source</param>
        /// <param name="max">The upper limit for the values to be generated</param>
        public void CappedRandom (RandomGenerator source, long max)
        {
            if (source == null)
                throw new ArgumentNullException (nameof (source));
            TH<#=tname#>Tensor_cappedRandom (handle, source.handle, max);
        }

        [DllImport ("caffe2")]
        extern static <#=ttype#> TH<#=tname#>Tensor_randperm (HType handle, IntPtr thgenerator, long max);
        
        /// <summary>
        ///  Populates the tensor with random values from 0 to n, using the provided random source generator.
        /// </summary>
        /// <param name="source">The random generator source</param>
        /// <param name="max">The upper limit for the values to be generated</param>
        public void Randperm (RandomGenerator source, long max)
        {
            if (source == null)
                throw new ArgumentNullException (nameof (source));
            TH<#=tname#>Tensor_randperm (handle, source.handle, max);
        }

        [DllImport ("caffe2")]
        extern static <#=ttype#> TH<#=tname#>Tensor_geometric (HType handle, IntPtr thgenerator, double p);
        
        /// <summary>
        ///  Populates the tensor with random values from 0 to n, using the provided random source generator.
        /// </summary>
        /// <param name="source">The random generator source</param>
        /// <param name="p"></param>
        public void Geometric (RandomGenerator source, double p)
        {
            if (source == null)
                throw new ArgumentNullException (nameof (source));
            TH<#=tname#>Tensor_geometric (handle, source.handle, p);
        }
        
        /// <summary>
        ///  Populates the tensor with random values from 0 to n, using a newly initialized Random number geneator.
        /// </summary>
        /// <param name="n">The upper limit for the values to be generated</param>        
        public void Random (long n)
        {
            using (var r = new RandomGenerator ())
                CappedRandom (r, n);
        }

<#
        // Float-specific random distributions.
            if (isFloat) {                    
#>
#if false
        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_bernoulli_<#=tname#>Tensor (HType self, IntPtr thgenerator, HType p);

        /// <summary>
        ///   Fills the tensor with values according to a Bernoulli distribution.
        /// </summary>
        /// <param name="source">The random generator source</param>
        /// <param name="p"></param>
        public void BernoulliTensor (RandomGenerator source, <#=tname#>Tensor p)
        {
            TH<#=tname#>Tensor_bernoulli_<#=tname#>Tensor(this.handle, source.handle, p.handle);
        }
#endif

        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_uniform (HType self, IntPtr thgenerator, double min, double max);

        /// <summary>
        ///   Fills the tensor with values according to a Bernoulli distribution.
        /// </summary>
        /// <param name="source">The random generator source</param>
        /// <param name="min">The lower bound for the random number range.</param>
        /// <param name="max">The upper bound for the random number range.</param>
        public void Uniform (RandomGenerator source, double min, double max)
        {
            TH<#=tname#>Tensor_uniform(this.handle, source.handle, min, max);
        }

        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_exponential (HType self, IntPtr thgenerator, double lambda);

        /// <summary>
        ///   Fills the tensor with values according to a exponential distribution.
        /// </summary>
        /// <param name="source">The random generator source</param>
        /// <param name="lambda"></param>
        public void Exponential (RandomGenerator source, double lambda)
        {
            TH<#=tname#>Tensor_exponential(this.handle, source.handle, lambda);
        }

        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_cauchy (HType self, IntPtr thgenerator, double median, double sigma);

        /// <summary>
        ///   Fills the tensor with values according to a Cauchy-Lorentz distribution.
        /// </summary>
        /// <param name="source">The random generator source</param>
        /// <param name="median"></param>
        /// <param name="sigma"></param>
        public void Cauchy (RandomGenerator source, double median, double sigma)
        {
            TH<#=tname#>Tensor_cauchy(this.handle, source.handle, median, sigma);
        }

        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_logNormal (HType self, IntPtr thgenerator, double mean, double stdv);

        /// <summary>
        ///   Fills the tensor with values according to a log-normal distribution.
        /// </summary>
        /// <param name="source">The random generator source</param>
        /// <param name="mean">The mean of the distribution.</param>
        /// <param name="stdv">The standard deviation of the distribution.</param>
        public void LogNormal (RandomGenerator source, double mean, double stdv)
        {
            TH<#=tname#>Tensor_logNormal(this.handle, source.handle, mean, stdv);
        }

        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_normal (HType self, IntPtr thgenerator, double mean, double stdv);

        /// <summary>
        ///   Fills the tensor with values according to a normal distribution.
        /// </summary>
        /// <param name="source">The random generator source</param>
        /// <param name="mean">The mean of the distribution.</param>
        /// <param name="stdv">The standard deviation of the distribution.</param>
        public void Normal (RandomGenerator source, double mean, double stdv)
        {
            TH<#=tname#>Tensor_normal(this.handle, source.handle, mean, stdv);
        }

        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_normal_means (HType self, IntPtr thgenerator, HType means, double stdv);

        /// <summary>
        ///   Fills the tensor with values according to a normal distribution. This version uses multiple means.
        /// </summary>
        /// <param name="source">The random generator source</param>
        /// <param name="means">The means of the distribution.</param>
        /// <param name="stdv">The standard deviation of the distribution.</param>
        public void NormalMeans (RandomGenerator source, <#=tname#>Tensor means, double stdv)
        {
            TH<#=tname#>Tensor_normal_means(this.handle, source.handle, means.handle, stdv);
        }

        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_normal_stddevs (HType self, IntPtr thgenerator, double mean, HType stdvs);

        /// <summary>
        ///   Fills the tensor with values according to a normal distribution. This version uses multiple standard deviations.
        /// </summary>
        /// <param name="source">The random generator source</param>
        /// <param name="mean">The mean of the distribution.</param>
        /// <param name="stdvs">The standard deviations of the distribution.</param>
        public void NormalStdvs (RandomGenerator source, double mean, <#=tname#>Tensor stdvs)
        {
            TH<#=tname#>Tensor_normal_stddevs(this.handle, source.handle, mean, stdvs.handle);
        }

        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_normal_means_stddevs (HType self, IntPtr thgenerator, HType means, HType stdvs);

        /// <summary>
        ///   Fills the tensor with values according to a normal distribution. This version uses multiple means and standard deviations.
        /// </summary>
        /// <param name="source">The random generator source</param>
        /// <param name="means">The means of the distribution.</param>
        /// <param name="stdvs">The standards deviation of the distribution.</param>
        public void NormalMeansStdvs (RandomGenerator source, <#=tname#>Tensor means, <#=tname#>Tensor stdvs)
        {
            TH<#=tname#>Tensor_normal_means_stddevs(this.handle, source.handle, means.handle, stdvs.handle);
        }

        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_multinomial (HType self, IntPtr thgenerator, HType prob_dist, int n_sample, int with_replacement);

        /// <summary>
        ///   Fills the tensor with values according to a multinomial distribution.
        /// </summary>
        /// <param name="source">The random generator source</param>
        /// <param name="prob_dist">The probability for each bucket.</param>
        /// <param name="n_sample">The number of samples to generate.</param>
        /// <param name="with_replacement"></param>
        public void Multinomial (RandomGenerator source, <#=tname#>Tensor prob_dist, int n_sample, int with_replacement)
        {
            TH<#=tname#>Tensor_multinomial(this.handle, source.handle, prob_dist.handle, n_sample, with_replacement);
        }
<#          } /* if */ #>
        
        /// <summary>
        ///   Get a string representation of the tensor.
        /// </summary>
        public override string ToString ()
        {
            var n = Dimensions;
            if (n == 0)
                    return "[]";

            StringBuilder sb = new StringBuilder ("[");
            for (int i = 0; i < n; i++) {
                    sb.Append (GetTensorDimension (i));
                    if (i + 1 < n)
                            sb.Append ("x");
            }
            sb.Append ("]");
            return sb.ToString ();
        }
<#
        // Idiom Op (Target, Source, Scalar)
        
            foreach (var op in new [] 
                { "Add", "Sub", "Mul", "Div", "LShift", "RShift", "Fmod", "Remainder", "BitAnd", "BitOr", "BitXor"}){
                
                // BitOr and BitXor not supported for floating point values, rather than
                // letting the runtime assert, do not surface the API.
                if ((op == "BitOr" || op == "BitXor") && isFloat)
                    continue;
#>                
        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_<#=op.ToLower()#> (HType result, HType source, <#=ttype#> value);
        
        // Not married to xthis yet - we have a few ways of solving this, sometimes
        // we could avoid allocation, but the API is ugly.  Or we could not have side-effects
        // which can also be surprising
        
        /// <summary>
        ///   Performs the <#=op#> operation on each element of the source with the
        ///   provided scalar.   The result tensor specified as the last parameters
        ///   is resized to match the source.
        /// </summary>
        /// <remarks>
        ///    For each element in the <see paramref="source"/> performs the <#=op#> operation
        ///    with <see paramref="value"/>.   The result is stored in the <see paramref="result"/>
        ///    tensor.
        /// </remarks>
        /// <param name="source">Source tensor on which the operation will take place.</param>
        /// <param name="value">The scalar value that the operation uses.</param>
        /// <param name="result">The tensor where the result will be placed</param>
        public static void <#=op#> (<#=tname#>Tensor source, <#=ttype#> value, <#=tname#>Tensor result)
        {
            // Arguments swapped to match Func<.., TResult> 
            TH<#=tname#>Tensor_<#=op.ToLower()#> (result.handle, source.handle, value);
        }
        
        /// <summary>
        ///   Performs the <#=op#> operation on each element of the tensor with the
        ///   <see paramref="value"/> and returns a new tensor with the result.
        /// </summary>
        /// <returns>
        ///   This returns a new tensor with the same shape as the tensor this operates on.
        /// </returns>
        /// <remarks>
        ///   If you want to avoid the allocation of a new tensor, you can use the 
        ///   alternative method <see cref="M:PytorchSharp.<#=op#>(PytorchSharp.<#=tname#>Tensor, <#=tname#>, PytorchSharp.<#=tname#>)"/>.
        /// </remarks>
        public <#=tname#>Tensor <#=op#> (<#=ttype#> value)
        {
            var result = new <#=tname#>Tensor ();
            <#=op#> (this, value, result);
            return result;
        }
<#          } /* foreach */ #>

<#
        // Idiom Op (Result, T, Scalar, Source2)
        
            foreach (var op in new [] { "CAdd", "CSub" }){
            
#>                
        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_<#=op.ToLower()#> (HType result, HType t, <#=ttype#> value, HType src);
        /// <summary>
        ///   Performs the <#=op#> operation on each element of the tensor with the
        ///   <see paramref="value"/> and returns a new tensor with the result.
        ///   where the result is t[idx] + value * src[idx]
        /// </summary>
        /// <returns>
        ///   This returns a new tensor with the same shape as the tensor this operates on.
        /// </returns>
        public <#=tname#>Tensor <#=op#> (<#=ttype#> value, <#=tname#>Tensor src)
        {
            if (src == null)
                throw new ArgumentNullException (nameof (src));
            var result = new <#=tname#>Tensor ();
            TH<#=tname#>Tensor_<#=op.ToLower()#> (result.handle, this.handle, value, src.handle);
            return result;
        }

<#          } /* foreach */ #>

<#
        // Idiom Op (Result)
            if (isFloat){
            foreach (var opdoc in new [] { 
                new { FloatOnly=true,  Name="Sigmoid", CName="", Doc="sigmoid" },
                new { FloatOnly=true,  Name="Log", CName="", Doc="natural logarithm" },
                new { FloatOnly=true,  Name="Lgamma", CName="", Doc="" },
                new { FloatOnly=true,  Name="Digamma", CName="", Doc="" },
                new { FloatOnly=true,  Name="Trigamma", CName="", Doc="" },
                new { FloatOnly=true,  Name="Polygamma", CName="", Doc="" },
                new { FloatOnly=true,  Name="Log10", CName="", Doc="" },
                new { FloatOnly=true,  Name="Log1p", CName="", Doc="" },
                new { FloatOnly=true,  Name="Log2", CName="", Doc="" },
                new { FloatOnly=true,  Name="Exp", CName="", Doc="" },
                new { FloatOnly=true,  Name="Expm1", CName="", Doc="" },
                new { FloatOnly=true,  Name="Cos", CName="", Doc="" },
                new { FloatOnly=true,  Name="Acos", CName="", Doc="" },
                new { FloatOnly=true,  Name="Cosh", CName="", Doc="" },
                new { FloatOnly=true,  Name="Sin", CName="", Doc="" },
                new { FloatOnly=true,  Name="Asin", CName="", Doc="" },
                new { FloatOnly=true,  Name="Sinh", CName="", Doc="" },
                new { FloatOnly=true,  Name="Tan", CName="", Doc="" },
                new { FloatOnly=true,  Name="Atan", CName="", Doc="" },
                new { FloatOnly=true,  Name="Atan2", CName="", Doc="" },
                new { FloatOnly=true,  Name="Tanh", CName="", Doc="" },
                new { FloatOnly=true,  Name="Erf", CName="", Doc="" },
                new { FloatOnly=true,  Name="Erfc", CName="", Doc="" },
                new { FloatOnly=true,  Name="Erfinv", CName="", Doc="" },
                new { FloatOnly=true,  Name="Sqrt", CName="", Doc="square root" },
                new { FloatOnly=true,  Name="Rsqrt", CName="", Doc="reciprocal of the square root of the elements of" },
                new { FloatOnly=true,  Name="Ceil", CName="", Doc="values rounded up to the nearest integer of the elements of" },
                new { FloatOnly=true,  Name="Floor", CName="", Doc="values rounded down to the nearest integer of the elements of" },
                new { FloatOnly=true,  Name="Round", CName="", Doc="values rounded to the nearest integer of the elements of" },
                new { FloatOnly=false, Name="Abs", CName="", Doc="absolute values of the elements of" },
                new { FloatOnly=true,  Name="Trunc", CName="", Doc="truncated integer values of the elements of" },
                new { FloatOnly=true,  Name="Frac", CName="", Doc="fractional portion of the elements of" },
                new { FloatOnly=false, Name="cinv", CName="", Doc="inverse value (1/x) of the elements of" },
                new { FloatOnly=false, Name="neg", CName="", Doc="inverted sign of the elements of" },
                new { FloatOnly=false, Name="ZerosLike", CName="zerosLike", Doc="zero-filled values of the same type as " },
                new { FloatOnly=false, Name="OnesLike", CName="onesLike", Doc="one-filled values of the same type as" },
                }){
                var op = opdoc.Name;
                var cname = (string.IsNullOrEmpty(opdoc.CName)) ? op.ToLower() : opdoc.CName;
                var doc = opdoc.Doc == "" ? opdoc.Name : opdoc.Doc;
                if (opdoc.FloatOnly && !isFloat)
                    continue;
#>                
        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_<#=cname#> (HType result, HType t);
        
        /// <summary>
        ///   Returns a new tensor with the <#=op#> of the elements of <see paramref="src"/>
        /// </summary>
        /// <returns>
        ///   This returns a new tensor with the same shape as the tensor this operates on.
        /// </returns>
        public <#=tname#>Tensor <#=op#> ()
        {
            var result = new <#=tname#>Tensor ();
            TH<#=tname#>Tensor_<#=cname#> (result.handle, this.handle);
            return result;
        }

<#          } /* foreach */ } #>

<#
        // Idiom Op (Result, T, Scalar, Source2)
            if (isFloat) {
#>                
        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_pow (HType result, HType x, <#=ttype#> y);

        /// <summary>
        ///   Returns a new tensor with <see paramref="this"/> raised to the power of <see paramref="y"/>.
        /// </summary>
        /// <param name="y">The exponent.</param>
        public <#=tname#>Tensor Pow (<#=ttype#> y)
        {
            var result = new <#=tname#>Tensor ();
            TH<#=tname#>Tensor_pow (result.handle, this.handle, y);
            return result;
        }

        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_tpow (HType result, <#=ttype#> x, HType y);

        /// <summary>
        ///   Returns a new tensor with <see paramref="x"/> raised to the power of <see paramref="this"/>.
        /// </summary>
        /// <param name="x">The base.</param>
        public <#=tname#>Tensor TPow (<#=ttype#> x)
        {
            var result = new <#=tname#>Tensor ();
            TH<#=tname#>Tensor_tpow (result.handle, x, this.handle);
            return result;
        }

<#          } /* if */ #>

        [DllImport ("caffe2")]
        extern static <#=accreal#> TH<#=tname#>Tensor_dot (HType self, HType other);
        
        /// <summary>
        ///   Returns the tensor product between this tensor and the provided one
        /// </summary>
        /// <param name="src">The right-hand-side operand.</param>
        /// <returns>
        ///   The dot product
        /// </returns>
        public <#=accreal#> Dot (<#=tname#>Tensor src)
        {
            if (src == null)
                throw new ArgumentNullException (nameof (src));
           
            return TH<#=tname#>Tensor_dot (this.handle, src.handle);
        }

        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_match (HType result, HType m1, HType m2, <#=ttype#> gain);
        
        /// <summary>
        ///   
        /// </summary>
        /// <param name="m2"></param>
        /// <param name="gain"></param>
        /// <returns>
        ///   This returns a new tensor with the same shape as the tensor this operates on.
        /// </returns>
        public <#=tname#>Tensor Match (<#=tname#>Tensor m2, <#=ttype#> gain)
        {
            if (m2 == null)
                throw new ArgumentNullException (nameof (m2));
            var result = new <#=tname#>Tensor ();
            TH<#=tname#>Tensor_match (result.handle, this.handle, m2.handle, gain);
            return result;
        }
<#
        // Idiom Op (Result, Tensor, Tensor 
        
            foreach (var opdoc in new [] { 
                new { Name="CMul", CName= "", ByteResult=false, Doc="element wise multiplication" },
                new { Name="CPow", CName= "", ByteResult=false, Doc="element-wise power operation" },
                new { Name="CDiv", CName= "", ByteResult=false, Doc="element-wise division " },
                new { Name="CLShift", CName= "", ByteResult=false, Doc="left shift operation of each element" },
                new { Name="CFMod", CName= "", ByteResult=false, Doc="element-wide remainder of the division (rounded towards zero)" },
                new { Name="CRemainder", CName= "", ByteResult=false, Doc="element-wise remainder of the division (rounded to nearest)" },
                new { Name="CBitAnd", CName= "", ByteResult=false, Doc="bitwise and operation of each element " },
                new { Name="CBitOr", CName= "", ByteResult=false, Doc="bitwise or operation of each element " },
                new { Name="CBitXor", CName= "", ByteResult=false, Doc="bitwise xor operation of each element " },
                new { Name="CMax", CName= "", ByteResult=false, Doc="" },
                new { Name="CMin", CName= "", ByteResult=false, Doc="" },
                new { Name="LtTensor", CName= "ltTensor", ByteResult=true, Doc="Compare two tensors for '<' and produce a byte tensor with the logical result." },
                new { Name="LeTensor", CName= "leTensor", ByteResult=true, Doc="Compare two tensors for '<=' and produce a byte tensor with the logical result." },
                new { Name="GtTensor", CName= "gtTensor", ByteResult=true, Doc="Compare two tensors for '>' and produce a byte tensor with the logical result." },
                new { Name="GeTensor", CName= "geTensor", ByteResult=true, Doc="Compare two tensors for '>=' and produce a byte tensor with the logical result." },
                new { Name="EqTensor", CName= "eqTensor", ByteResult=true, Doc="Compare two tensors for equality and produce a byte tensor with the logical result." },
                new { Name="NeTensor", CName= "neTensor", ByteResult=true, Doc="Compare two tensors and inequality and produce a byte tensor with the logical result." },
                new { Name="LtTensorT", CName= "ltTensorT", ByteResult=false, Doc="Compare two tensors for '<' and produce a tensor with the logical result." },
                new { Name="LeTensorT", CName= "leTensorT", ByteResult=false, Doc="Compare two tensors for '<=' and produce a tensor with the logical result." },
                new { Name="GtTensorT", CName= "gtTensorT", ByteResult=false, Doc="Compare two tensors for '>' and produce a tensor with the logical result." },
                new { Name="GeTensorT", CName= "geTensorT", ByteResult=false, Doc="Compare two tensors for '>=' and produce a tensor with the logical result." },
                new { Name="EqTensorT", CName= "eqTensorT", ByteResult=false, Doc="Compare two tensors for equality and produce a tensor with the logical result." },
                new { Name="NeTensorT", CName= "neTensorT", ByteResult=false, Doc="Compare two tensors and inequality and produce a tensor with the logical result." },
                }){
                var op = opdoc.Name;
                var doc = opdoc.Doc;
                var cname = (string.IsNullOrEmpty(opdoc.CName)) ? op.ToLower() : opdoc.CName;
                var resultType = opdoc.ByteResult ? "ByteTensor" : tname +"Tensor";
                var resultHType = opdoc.ByteResult ? "ByteTensor.HType" : "HType";

#>                
        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_<#=cname#> (<#=resultHType#> result, HType t, HType src);
        
        /// <summary>
        ///   Performs an <#=op#> of the tensor with the provided 
        ///   <see paramref="src"/> tensor and returns a new tensor with the result.
        /// </summary>
        /// <param name="src">The right-hand-side operand.</param>
        /// <returns>
        ///   This returns a new tensor with the same shape as the tensor this operates on.
        /// </returns>
        public <#=resultType#> <#=op#> (<#=tname#>Tensor src)
        {
            if (src == null)
                throw new ArgumentNullException (nameof (src));
            var result = new <#=resultType#> ();
            TH<#=tname#>Tensor_<#=cname#> (result.handle, this.handle, src.handle);
            return result;
        }

<#          } /* foreach */ #>
<#
        // Idiom Op (Result, Tensor, scalar 
        
            foreach (var opdoc in new [] { 
                new { Name="CMaxValue", CName= "", ByteResult=false, Doc="" },
                new { Name="CMinValue", CName= "", ByteResult=false, Doc="" },
                new { Name="LtValue", CName= "ltValue", ByteResult=true, Doc="Compare a tensor and a scalar for '<' and produce a byte tensor with the logical result." },
                new { Name="LeValue", CName= "leValue", ByteResult=true, Doc="Compare a tensor and a scalar for '<=' and produce a byte tensor with the logical result." },
                new { Name="GtValue", CName= "gtValue", ByteResult=true, Doc="Compare a tensor and a scalar for '>' and produce a byte tensor with the logical result." },
                new { Name="GeValue", CName= "geValue", ByteResult=true, Doc="Compare a tensor and a scalar for '>=' and produce a byte tensor with the logical result." },
                new { Name="EqValue", CName= "eqValue", ByteResult=true, Doc="Compare a tensor and a scalar for equality and produce a byte tensor with the logical result." },
                new { Name="NeValue", CName= "neValue", ByteResult=true, Doc="Compare a tensor and a scalar and inequality and produce a byte tensor with the logical result." },
                new { Name="LtValueT", CName= "ltValueT", ByteResult=false, Doc="Compare a tensor and a scalar for '<' and produce a tensor with the logical result." },
                new { Name="LeValueT", CName= "leValueT", ByteResult=false, Doc="Compare a tensor and a scalar for '<=' and produce a tensor with the logical result." },
                new { Name="GtValueT", CName= "gtValueT", ByteResult=false, Doc="Compare a tensor and a scalar for '>' and produce a tensor with the logical result." },
                new { Name="GeValueT", CName= "geValueT", ByteResult=false, Doc="Compare a tensor and a scalar for '>=' and produce a tensor with the logical result." },
                new { Name="EqValueT", CName= "eqValueT", ByteResult=false, Doc="Compare a tensor and a scalar for equality and produce a tensor with the logical result." },
                new { Name="NeValueT", CName= "neValueT", ByteResult=false, Doc="Compare a tensor and a scalar and inequality and produce a tensor with the logical result." },
                }){
                var op = opdoc.Name;
                var doc = opdoc.Doc;
                var cname = (string.IsNullOrEmpty(opdoc.CName)) ? op.ToLower() : opdoc.CName;
                var resultType = opdoc.ByteResult ? "ByteTensor" : tname +"Tensor";
                var resultHType = opdoc.ByteResult ? "ByteTensor.HType" : "HType";
            
#>                
        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_<#=cname#> (<#=resultHType#> result, HType t, <#=ttype#> value);
        
        /// <summary>
        ///   Performs an <#=op#> of the tensor with the provided 
        ///   <see paramref="src"/> tensor and returns a new tensor with the result.
        /// </summary>
        /// <param name="src">The right-hand-side operand.</param>
        /// <returns>
        ///   This returns a new tensor with the same shape as the tensor this operates on.
        /// </returns>
        public <#=resultType#> <#=op#> (<#=ttype#> src)
        {
            var result = new <#=resultType#> ();
            TH<#=tname#>Tensor_<#=cname#> (result.handle, this.handle, src);
            return result;
        }

<#          } /* foreach */ #>
        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_lerp (HType result, HType self, HType other, <#=ttype#> weight);
        
        /// <summary>
        ///   LERP
        /// </summary>
        /// <param name="other">The right-hand-side operand.</param>
        /// <param name="weight"></param>
        public <#=tname#>Tensor LERP (<#=tname#>Tensor other, <#=ttype#> weight)
        {
            if (other == null)
                throw new ArgumentNullException (nameof (other));
            var result = new <#=tname#>Tensor();
            TH<#=tname#>Tensor_lerp (result.handle, this.handle, other.handle, weight);
            return result;
        }

        [DllImport ("caffe2")]
        extern static int TH<#=tname#>Tensor_equal (HType t, HType src);
        
        /// <summary>
        ///   Compare the tensor with another for complete equality.
        /// </summary>
        /// <param name="other">The right-hand-side operand.</param>
        public int Equal (<#=tname#>Tensor other)
        {
            if (other == null)
                throw new ArgumentNullException (nameof (other));
            return TH<#=tname#>Tensor_equal (this.handle, other.handle);
        }
<#
        // Idiom Op (Result, Tensor, scalar, scalar 
        
            foreach (var opdoc in new [] { 
                new { Name="AddScaled", CName= "add_scaled", Doc="" },
                new { Name="SubScaled", CName= "sub_scaled", Doc="" },
                new { Name="Clamp", CName= "", Doc="Clip the input elements to a range." },
                }){
                var op = opdoc.Name;
                var doc = opdoc.Doc;
                var cname = (string.IsNullOrEmpty(opdoc.CName)) ? op.ToLower() : opdoc.CName;
                var resultType = tname +"Tensor";
                var resultHType = "HType";
            
#>                
        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_<#=cname#> (HType result, HType t, <#=ttype#> value1, <#=ttype#> value2);
        
        /// <summary>
        ///   Performs an <#=op#> of the tensor with the provided 
        ///   <see paramref="src"/> tensor and returns a new tensor with the result.
        /// </summary>
        /// <param name="value1"></param>
        /// <param name="value2"></param>
        /// <returns>
        ///   This returns a new tensor with the same shape as the tensor this operates on.
        /// </returns>
        public <#=resultType#> <#=op#> (<#=ttype#> value1, <#=ttype#> value2)
        {
            var result = new <#=resultType#> ();
            TH<#=tname#>Tensor_<#=cname#> (result.handle, this.handle, value1, value2);
            return result;
        }

<#          } /* foreach */ #>
<#
        // Idiom Op (Result, Tensor, Scalar, Tensor, Tensor)
        
            foreach (var opdoc in new [] { 
                new { Name="AddCMul", Doc="" },
                new { Name="AddCDiv", Doc="" },
                }){
                var op = opdoc.Name;
                var doc = opdoc.Doc;
            
#>                
        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_<#=op.ToLower()#> (HType result, HType t, <#=ttype#> value, HType src1, HType src2);
        
        /// <summary>
        ///   Performs <#=op#> of the tensor with the provided 
        ///   <see paramref="src1"/> and <see paramref="src1"/> tensors and returns a new tensor with the result.
        /// </summary>
        /// <param name="value"></param>
        /// <param name="src1"></param>
        /// <param name="src2"></param>
        /// <returns>
        ///   This returns a new tensor with the same shape as the tensor this operates on.
        /// </returns>
        public <#=tname#>Tensor <#=op#> (<#=ttype#> value, <#=tname#>Tensor src1, <#=tname#>Tensor src2)
        {
            if (src1 == null)
                throw new ArgumentNullException (nameof (src1));
            if (src2 == null)
                throw new ArgumentNullException (nameof (src2));
            var result = new <#=tname#>Tensor ();
            TH<#=tname#>Tensor_<#=op.ToLower()#> (result.handle, this.handle, value, src1.handle, src2.handle);
            return result;
        }

<#          } /* foreach */ #>
<#
        // Idiom Op (Result, Scalar, Tensor, Scalar, Tensor, Tensor)
        
            foreach (var opdoc in new [] { 
                new { Name="AddMV", Doc="" },
                new { Name="AddMM", Doc="" },
                new { Name="AddR", Doc="" },
                new { Name="AddBMM", Doc="" },
                new { Name="BAddBMM", Doc="" },
                }){
                var op = opdoc.Name;
                var doc = opdoc.Doc;
            
#>                
        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_<#=op.ToLower()#> (HType result, <#=ttype#> beta, HType t, <#=ttype#> alpha, HType src1, HType src2);
        
        /// <summary>
        ///   Performs <#=op#> of the tensor with the provided 
        ///   <see paramref="src1"/> and <see paramref="src1"/> tensors and returns a new tensor with the result.
        /// </summary>
        /// <param name="beta"></param>
        /// <param name="alpha"></param>
        /// <param name="src1"></param>
        /// <param name="src2"></param>
        /// <returns>
        ///   This returns a new tensor with the same shape as the tensor this operates on.
        /// </returns>
        public <#=tname#>Tensor <#=op#> (<#=ttype#> beta, <#=ttype#> alpha, <#=tname#>Tensor src1, <#=tname#>Tensor src2)
        {
            if (src1 == null)
                throw new ArgumentNullException (nameof (src1));
            if (src2 == null)
                throw new ArgumentNullException (nameof (src2));
            var result = new <#=tname#>Tensor ();
            TH<#=tname#>Tensor_<#=op.ToLower()#> (result.handle, beta, this.handle, alpha, src1.handle, src2.handle);
            return result;
        }

<#          } /* foreach */ #>
<#
        // Idiom Op (Result, Tensor, Tensor 
        
            foreach (var opdoc in new [] { 
                new { Name="MinAll", Doc="minimum value", Ret=ttype },
                new { Name="MaxAll", Doc="maximum value", Ret=ttype },
                new { Name="MedianAll", Doc="median", Ret=ttype },
                new { Name="SumAll", Doc="sum", Ret=accreal},
                new { Name="ProdAll", Doc="product", Ret=accreal },
                }){
                var op = opdoc.Name;
                var doc = opdoc.Doc;
                var ret = opdoc.Ret;
#> 
        [DllImport ("caffe2")]
        extern static <#=ret#> TH<#=tname#>Tensor_<#=op.ToLower()#> (HType result);

        /// <summary>
        ///   Returns the <#=doc#> of the elements in the tensor.
        /// </summary>
        /// <returns>
        ///   The <#=doc#> of the tensor.
        /// </returns>
        public <#=ret#> <#=op#> ()
        {
            return TH<#=tname#>Tensor_<#=op.ToLower()#> (this.handle);
        }
<#          } /* foreach */ #>

<#
        // Idiom Op (Result, Scalar, Scalar, Long)
            if (isFloat) {
            foreach (var opdoc in new [] { 
                new { Name="Linspace", Doc="" },
                new { Name="Logspace", Doc="" },
                }){
                var op = opdoc.Name;
                var doc = opdoc.Doc;
            
#>                
        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_<#=op.ToLower()#> (HType result, <#=ttype#> a, <#=ttype#> b, long n);
        
        /// <summary>
        ///   Performs <#=op#> of the tensor with the provided 
        ///   <see paramref="src1"/> and <see paramref="src1"/> tensors and returns a new tensor with the result.
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <param name="n"></param>
        /// <returns>
        ///   This returns a new tensor with the same shape as the tensor this operates on.
        /// </returns>
        public <#=tname#>Tensor <#=op#> (<#=ttype#> a, <#=ttype#> b, long n)
        {
            var result = new <#=tname#>Tensor ();
            TH<#=tname#>Tensor_<#=op.ToLower()#> (result.handle, a, b, n);
            return result;
        }

<#          } /* foreach */ }#>

        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_indexSelect (HType tensor, HType src, int dim, LongTensor.HType index);
        
        /// <summary>
        ///   Returns a new Tensor which indexes the original Tensor along dimension dim
        ///   using the entries in index.  The returned Tensor has the same number of dimensions as the 
        ///   original Tensor. The returned Tensor does not use the same storage as the original Tensor.
        /// </summary>
        /// <param name="dim">Dimension to select</param>
        /// <param name="index">Entries to extract</param>
        public <#=tname#>Tensor IndexSelect (int dim, LongTensor index)
        {
            if (index == null)
                throw new ArgumentNullException (nameof (index));
             
            var res = new <#=tname#>Tensor ();
            TH<#=tname#>Tensor_indexSelect (res.handle, handle, dim, index.handle);
            return res;
        }
        
        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_indexCopy (HType tensor, int dim, LongTensor.HType index, HType src);
        
        /// <summary>
        ///   Copies the elements of tensor into the original tensor by selecting the indices in the order 
        ///   given in index. The shape of tensor must exactly match the elements indexed or an error will be thrown.
        /// </summary>
        /// <param name="dim">Dimension to select for the copy</param>
        /// <param name="index">Entries to copy</param>
        /// <param name="src">Tensor to copy the data from.</param>
        public void IndexCopy (int dim, LongTensor index, <#=tname#>Tensor src)
        {
            if (src == null)
                throw new ArgumentNullException (nameof (src));
            if (index == null)
                throw new ArgumentNullException (nameof (index));
            
            TH<#=tname#>Tensor_indexCopy (handle, dim, index.handle, src.handle);
        }

        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_indexAdd (HType tensor, int dim, LongTensor.HType index, HType src);
        
        /// <summary>
        ///   Adds the elements of tensor into the original tensor by selecting the indices in the order 
        ///   given in index. The shape of tensor must exactly match the elements indexed or an error will be thrown.
        /// </summary>
        /// <param name="dim">Dimension to select for the add</param>
        /// <param name="index">Entries to copy</param>
        /// <param name="src">Tensor to copy the data from.</param>
        public void IndexAdd (int dim, LongTensor index, <#=tname#>Tensor src)
        {
            if (src == null)
                throw new ArgumentNullException (nameof (src));
            if (index == null)
                throw new ArgumentNullException (nameof (index));
            TH<#=tname#>Tensor_indexAdd (handle, dim, index.handle, src.handle);
        }

        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_indexFill (HType tensor, int dim, LongTensor.HType index, <#=ttype#> value);
        
        /// <summary>
        ///   Uses the given value to overwrite the original tensor by selecting the indices in the order 
        ///   given in index. The shape of tensor must exactly match the elements indexed or an error will be thrown.
        /// </summary>
        /// <param name="dim">Dimension to select for the fill</param>
        /// <param name="index">Entries to copy</param>
        /// <param name="value">The value to write.</param>
        public void IndexFill (int dim, LongTensor index, <#=ttype#> value)
        {
            if (index == null)
                throw new ArgumentNullException (nameof (index));
            TH<#=tname#>Tensor_indexFill (handle, dim, index.handle, value);
        }

        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_take (HType self, HType src, LongTensor.HType index);

        /// <summary>
        ///   Take
        /// </summary>        
        /// <param name="src"></param>
        /// <param name="index">Indices of entries to copy.</param>
        public void Take (<#=tname#>Tensor src, LongTensor index)
        {
            if (src == null)
                throw new ArgumentNullException (nameof (src));
            if (index == null)
                throw new ArgumentNullException (nameof (index));
            TH<#=tname#>Tensor_take (handle, src.handle, index.handle);
        }

        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_put (HType self, LongTensor.HType index, HType src, int accumulate);

        /// <summary>
        ///   Put
        /// </summary>
        /// <param name="index">Indices of entries to copy.</param>
        /// <param name="src"></param>
        /// <param name="accumulate"></param>
        public void Put (LongTensor index, <#=tname#>Tensor src, int accumulate)
        {
            if (src == null)
                throw new ArgumentNullException (nameof (src));
            if (index == null)
                throw new ArgumentNullException (nameof (index));
            TH<#=tname#>Tensor_put (handle, index.handle, src.handle, accumulate);
        }

        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_gather (HType self, HType src, int dim, LongTensor.HType index);

        /// <summary>
        ///   Gather
        /// </summary>
        /// <param name="src"></param>
        /// <param name="dim"></param>
        /// <param name="index">Indices of entries to copy.</param>
        public void Gather (<#=tname#>Tensor src, int dim, LongTensor index)
        {
            if (src == null)
                throw new ArgumentNullException (nameof (src));
            if (index == null)
                throw new ArgumentNullException (nameof (index));
            TH<#=tname#>Tensor_gather (handle, src.handle, dim, index.handle);
        }

        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_scatter (HType self, int dim, LongTensor.HType index, HType src);

        /// <summary>
        ///   Scatter
        /// </summary>
        /// <param name="dim"></param>
        /// <param name="index">Indices of entries to copy.</param>
        /// <param name="src"></param>
        public void Scatter (int dim, LongTensor index, <#=tname#>Tensor src)
        {
            if (src == null)
                throw new ArgumentNullException (nameof (src));
            if (index == null)
                throw new ArgumentNullException (nameof (index));
            TH<#=tname#>Tensor_scatter (handle, dim, index.handle, src.handle);
        }

        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_scatterAdd (HType self, int dim, LongTensor.HType index, HType src);

        /// <summary>
        ///   ScatterAdd
        /// </summary>
        /// <param name="dim"></param>
        /// <param name="index">Indices of entries to copy.</param>
        /// <param name="src"></param>
        public void ScatterAdd (int dim, LongTensor index, <#=tname#>Tensor src)
        {
            if (src == null)
                throw new ArgumentNullException (nameof (src));
            if (index == null)
                throw new ArgumentNullException (nameof (index));
            TH<#=tname#>Tensor_scatterAdd (handle, dim, index.handle, src.handle);
        }

        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_scatterFill (HType self, int dim, LongTensor.HType index, <#=ttype#> value);

        /// <summary>
        ///   ScatterAdd
        /// </summary>
        /// <param name="dim"></param>
        /// <param name="index">Indices of entries to copy.</param>
        /// <param name="value"></param>
        public void ScatterFill (int dim, LongTensor index, <#=ttype#> value)
        {
            if (index == null)
                throw new ArgumentNullException (nameof (index));
            TH<#=tname#>Tensor_scatterFill (handle, dim, index.handle, value);
        }

        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_copy (HType tensor, HType src);
        
        /// <summary>
        ///   Copies the elements of a tensor into the original tensor. 
        ///   The shape of the tensors must exactly match or an error will be thrown.
        /// </summary>
        /// <param name="src">Tensor to copy the data from.</param>
        public void Copy (<#=tname#>Tensor src)
        {
            if (src == null)
                throw new ArgumentNullException (nameof (src));
            TH<#=tname#>Tensor_copy (this.handle, src.handle);
        }

<#
        foreach (var srcType in new string [] { "Byte", "Short", "Int", "Long", "Float", "Double" }) {
#>
        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_copy<#=srcType#> (HType tensor, <#=srcType#>Tensor.HType src);
        
        /// <summary>
        ///   Copies the elements of a <#=srcType.ToLower()#> tensor into the original tensor. 
        ///   The shape of the tensors must exactly match or an error will be thrown.
        /// </summary>
        /// <param name="src">Tensor to copy the data from.</param>
        public void Copy<#=srcType#> (<#=srcType#>Tensor src)
        {
            if (src == null)
                throw new ArgumentNullException (nameof (src));
            TH<#=tname#>Tensor_copy<#=srcType#> (this.handle, src.handle);
        }

<#          } /* foreach */ #>        
<#
            if (isByte) {
            foreach (var opdoc in new [] { 
                new { Name="LogicalAndAll", CName="logicalAndAll", Doc="AND" },
                new { Name="LogicalAnyAll", CName="logicalAnyAll", Doc="OR" }
                }){
                var op = opdoc.Name;
                var doc = opdoc.Doc;
                var cname = opdoc.CName;
#>
        [DllImport ("caffe2")]
        extern static int TH<#=tname#>Tensor_<#=cname#> (HType self);
        
        /// <summary>
        ///   Compares all the elements of the tensor using '<#=doc#>' and returns the result as an integer, either 0 or 1. 
        /// </summary>
        public int <#=op#> ()
        {
            return TH<#=tname#>Tensor_<#=cname#> (this.handle);
        }
<#          } /* foreach */ } #>        
<#
            if (isByte) {
            foreach (var opdoc in new [] { 
                new { Name="LogicalAnd", CName="logicalAnd", ByteOnly=true, Doc="AND" },
                new { Name="LogicalAny", CName="logicalAny", ByteOnly=true, Doc="OR" }
                }){
                var op = opdoc.Name;
                var doc = opdoc.Doc;
                var cname = opdoc.CName;
#>
        [DllImport ("caffe2")]
        extern static int TH<#=tname#>Tensor_<#=cname#> (HType result, HType self, int dimension, int keepdim);
        
        /// <summary>
        ///   Compares all the elements of the tensor using '<#=doc#>' and returns the result as an integer, either 0 or 1. 
        /// </summary>
        /// <param name="dimension">The dimension to process along.</param>
        /// <param name="keepdim">1 if the reduction dimension should be kept, 0 otherwise.</param>
        public <#=tname#>Tensor <#=op#> (int dimension, int keepdim)
        {
            var result = new <#=tname#>Tensor ();
            TH<#=tname#>Tensor_<#=cname#> (result.handle, this.handle, dimension, keepdim);
            return result;
        }
<#          } /* foreach */ } #>     
<#
            foreach (var opdoc in new [] { 
                new { Name="Sum", Doc="sum" },
                new { Name="Prod", Doc="product" }
                }){
                var op = opdoc.Name;
                var doc = opdoc.Doc;
                var cname = op.ToLower();
#>
        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_<#=cname#> (HType result, HType self, int dimension, int keepdim);
        
        /// <summary>
        ///   Computes the <#=doc#> of all the elements of the tensor along the given dimension. 
        /// </summary>
        /// <param name="dimension">The dimension to process along.</param>
        /// <param name="keepdim">1 if the reduction dimension should be kept, 0 otherwise.</param>
        public <#=tname#>Tensor <#=op#> (int dimension, int keepdim)
        {
            var result = new <#=tname#>Tensor ();
            TH<#=tname#>Tensor_<#=cname#> (result.handle, this.handle, dimension, keepdim);
            return result;
        }

        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_cum<#=cname#> (HType result, HType self, int dimension);
        
        /// <summary>
        ///   Computes the cumulative <#=doc#> of all the elements of the tensor along the given dimension. 
        /// </summary>
        /// <param name="dimension">The dimension to process along.</param>
        public <#=tname#>Tensor Cumulative<#=op#> (int dimension)
        {
            var result = new <#=tname#>Tensor ();
            TH<#=tname#>Tensor_cum<#=cname#> (result.handle, this.handle, dimension);
            return result;
        }
<#          } /* foreach */ #>     
<#
            foreach (var opdoc in new [] { 
                new { Name="Max", Doc="max" },
                new { Name="Min", Doc="min" },
                new { Name="Mode", Doc="mode" },
                new { Name="Median", Doc="median" },
                }){
                var op = opdoc.Name;
                var doc = opdoc.Doc;
                var cname = op.ToLower();
#>
        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_<#=cname#> (HType values, LongTensor.HType indices, HType self, int dimension, int keepdim);
        
        /// <summary>
        ///   Computes the <#=doc#> of all the elements of the tensor along the given dimension. 
        /// </summary>
        /// <param name="dimension">The dimension to process along.</param>
        /// <param name="keepdim">1 if the reduction dimension should be kept, 0 otherwise.</param>
        /// <returns>A tuple containing the values and indices of the resulting elements.</returns>
        public System.Tuple<<#=tname#>Tensor, LongTensor> <#=op#> (int dimension, int keepdim)
        {
            var values = new <#=tname#>Tensor ();
            var indices = new LongTensor ();
            TH<#=tname#>Tensor_<#=cname#> (values.handle, indices.handle, this.handle, dimension, keepdim);
            return new System.Tuple<<#=tname#>Tensor, LongTensor>(values, indices);
        }
<#          } /* foreach */ #>     

        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_kthvalue (HType values, LongTensor.HType indices, HType self, long k, int dimension, int keepdim);
        
        /// <summary>
        ///   Computes the kth value of all the elements of the tensor along the given dimension. 
        /// </summary>
        /// <param name="k">The value for 'k' in 'kth'.</param>
        /// <param name="dimension">The dimension to process along.</param>
        /// <param name="keepdim">1 if the reduction dimension should be kept, 0 otherwise.</param>
        /// <returns>A tuple containing the values and indices of the kth element of each dimension.</returns>
        public System.Tuple<<#=tname#>Tensor, LongTensor> KthValue (long k, int dimension, int keepdim)
        {
            var values = new <#=tname#>Tensor ();
            var indices = new LongTensor ();
            TH<#=tname#>Tensor_kthvalue (values.handle, indices.handle, this.handle, k, dimension, keepdim);
            return new System.Tuple<<#=tname#>Tensor, LongTensor>(values, indices);
        }

        [DllImport ("caffe2")]
        extern static <#=accreal#> TH<#=tname#>Tensor_trace (HType self);
        
        /// <summary>
        ///   Computes the trace of the tensor. 
        /// </summary>
        public <#=accreal#> Trace ()
        {
            return TH<#=tname#>Tensor_trace(this.handle);
        }

        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_sign (HType result, HType self);
        
        /// <summary>
        ///   Computes the sign of the tensor. 
        /// </summary>
        public <#=tname#>Tensor Sign ()
        {
            var result = new <#=tname#>Tensor();
            TH<#=tname#>Tensor_sign(result.handle, this.handle);
            return result;
        }

        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_cross (HType result, HType a, HType b);
        
        /// <summary>
        ///   Computes the cross product of two tensors. 
        /// </summary>
        /// <param name="other">The right-hand-side tensor.</param>
        public <#=tname#>Tensor CrossProduct (<#=tname#>Tensor other)
        {
            var result = new <#=tname#>Tensor();
            TH<#=tname#>Tensor_cross(result.handle, this.handle, other.handle);
            return result;
        }

        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_diag (HType result, HType self, int k);
        
        /// <summary>
        ///   Gets the diagonal of the tensor. 
        /// </summary>
        /// <param name="k"></param>
        public <#=tname#>Tensor Diagonal (int k)
        {
            var result = new <#=tname#>Tensor();
            TH<#=tname#>Tensor_diag(result.handle, this.handle, k);
            return result;
        }

        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_eye (HType result, long m, long n);
        
        /// <summary>
        ///   Eye. 
        /// </summary>
        /// <param name="m"></param>
        /// <param name="n"></param>
        public static <#=tname#>Tensor Eye (long m, long n)
        {
            var result = new <#=tname#>Tensor();
            TH<#=tname#>Tensor_eye(result.handle, m, n);
            return result;
        }

        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_range (HType result, <#=accreal#> xmin, <#=accreal#> xmax, <#=accreal#> step);
        
        /// <summary>
        ///   Create a range spanning from xmin to xmax, with 'step' between each value.
        /// </summary>
        /// <param name="xmin">The lower bound of the range.</param>
        /// <param name="xmax">The upper bound of the range.</param>
        /// <param name="step">The value step.</param>
        public static <#=tname#>Tensor Range (<#=accreal#> xmin, <#=accreal#> xmax, <#=accreal#> step)
        {
            var result = new <#=tname#>Tensor();
            TH<#=tname#>Tensor_range(result.handle, xmin, xmax, step);
            return result;
        }

        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_arange (HType result, <#=accreal#> xmin, <#=accreal#> xmax, <#=accreal#> step);
        
        /// <summary>
        ///   Create a range spanning from xmin to xmax, with 'step' between each value.
        /// </summary>
        /// <param name="xmin">The lower bound of the range.</param>
        /// <param name="xmax">The upper bound of the range.</param>
        /// <param name="step">The value step.</param>
        public static <#=tname#>Tensor ARange (<#=accreal#> xmin, <#=accreal#> xmax, <#=accreal#> step)
        {
            var result = new <#=tname#>Tensor();
            TH<#=tname#>Tensor_arange(result.handle, xmin, xmax, step);
            return result;
        }

        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_sort (HType values, LongTensor.HType indices, HType self, int dimension, int descending);
        
        /// <summary>
        ///   Sorts the elements of the tensor along the given dimension. 
        /// </summary>
        /// <param name="dimension">The dimension to sort along.</param>
        /// <param name="descending">0 if ascending, 1 if descending.</param>
        /// <returns>A tuple containing the values and indices of the sorted elements.</returns>
        public System.Tuple<<#=tname#>Tensor, LongTensor> Sort (int dimension, int descending)
        {
            var values = new <#=tname#>Tensor ();
            var indices = new LongTensor ();
            TH<#=tname#>Tensor_sort (values.handle, indices.handle, this.handle, dimension, descending);
            return new System.Tuple<<#=tname#>Tensor, LongTensor>(values, indices);
        }

        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_topk (HType values, LongTensor.HType indices, HType self, long k, int dim, int dir, int sorted);
        
        /// <summary>
        ///   Finds the top k of all the elements of the tensor along the given dimension. 
        /// </summary>
        /// <param name="k">The number of elements to fetch.</param>
        /// <param name="dim">The dimension along which to sort and find k elements.</param>
        /// <param name="dir">0 if ascending, 1 if descending.</param>
        /// <param name="sorted">1 if the result should be sorted, 0 if they should keep their original order.</param>
        /// <returns>A tuple containing the values and indices of the top 'k' elements.</returns>
        public System.Tuple<<#=tname#>Tensor, LongTensor> TopK (long k, int dim, int dir, int sorted)
        {
            var values = new <#=tname#>Tensor ();
            var indices = new LongTensor ();
            TH<#=tname#>Tensor_topk (values.handle, indices.handle, this.handle, k, dim, dir, sorted);
            return new System.Tuple<<#=tname#>Tensor, LongTensor>(values, indices);
        }

        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_tril (HType result, HType self, long k);
        
        /// <summary>
        ///   Lower triangle. 
        /// </summary>
        /// <param name="k"></param>
        public <#=tname#>Tensor TriL (long k)
        {
            var result = new <#=tname#>Tensor ();
            TH<#=tname#>Tensor_tril (result.handle, this.handle, k);
            return result;
        }

        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_triu (HType result, HType self, long k);
        
        /// <summary>
        ///   Upper triangle. 
        /// </summary>
        /// <param name="k"></param>
        public <#=tname#>Tensor TriU (long k)
        {
            var result = new <#=tname#>Tensor ();
            TH<#=tname#>Tensor_triu (result.handle, this.handle, k);
            return result;
        }

        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_cat (HType result, HType ta, HType tb, int dimension);
        
        /// <summary>
        ///   Concatenate tensors along the given dimesion.
        /// </summary>
        /// <param name="other">The second tensor.</param>
        /// <param name="dimension">The dimension along which to concatenate.</param>
        public <#=tname#>Tensor Concatenate (<#=tname#>Tensor other, int dimension)
        {
            var result = new <#=tname#>Tensor ();
            TH<#=tname#>Tensor_cat (result.handle, this.handle, other.handle, dimension);
            return result;
        }

        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_catArray (HType result, HType[] ta, int count, int dimension);
#if false        
// NOTE: We need to determine the right marshalling for an array of handles.
        /// <summary>
        ///   Concatenate tensors along the given dimesion.
        /// </summary>
        /// <param name="tensors">A collection of tensors..</param>
        /// <param name="dimension">The dimension along which to concatenate.</param>
        public static <#=tname#>Tensor Concatenate (IEnumerable<<#=tname#>Tensor> tensors, int dimension)
        {
            var result = new <#=tname#>Tensor ();
            var handleArray = tensors.Select(t => t.handle).ToArray();
            TH<#=tname#>Tensor_catArray (result.handle, handleArray, (int)handleArray.Length, dimension);
            return result;
        }
#endif
<#
            if (isFloat) {
#>
        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_mean (HType result, HType self, int dimension, int keepdim);
        
        /// <summary>
        ///   Compute the mean of all tensor elements along the given dimension. 
        /// </summary>
        /// <param name="dimension">The dimension to process along.</param>
        /// <param name="keepdim">1 if the reduction dimension should be kept, 0 otherwise.</param>
        public <#=tname#>Tensor Mean (int dimension, int keepdim)
        {
            var result = new <#=tname#>Tensor();
            TH<#=tname#>Tensor_mean (result.handle, this.handle, dimension, keepdim);
            return result;
        }

        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_std (HType result, HType self, int dimension, int biased, int keepdim);

        /// <summary>
        ///   Compute the standard deviation of all tensor elements along the given dimension. 
        /// </summary>
        /// <param name="dimension">The dimension to process along.</param>
        /// <param name="biased"></param>
        /// <param name="keepdim">1 if the reduction dimension should be kept, 0 otherwise.</param>
        public <#=tname#>Tensor Std (int dimension, int biased, int keepdim)
        {
            var result = new <#=tname#>Tensor();
            TH<#=tname#>Tensor_std (result.handle, this.handle, dimension, biased, keepdim);
            return result;
        }

        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_var (HType result, HType self, int dimension, int biased, int keepdim);

        /// <summary>
        ///   Compute the variance of all tensor elements along the given dimension. 
        /// </summary>
        /// <param name="dimension">The dimension to process along.</param>
        /// <param name="biased"></param>
        /// <param name="keepdim">1 if the reduction dimension should be kept, 0 otherwise.</param>
        public <#=tname#>Tensor Var (int dimension, int biased, int keepdim)
        {
            var result = new <#=tname#>Tensor();
            TH<#=tname#>Tensor_var (result.handle, this.handle, dimension, biased, keepdim);
            return result;
        }

        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_norm (HType result, HType self, <#=ttype#> value,  int dimension, int keepdim);

        /// <summary>
        ///   Compute the norm of all tensor elements along the given dimension. 
        /// </summary>
        /// <param name="value"></param>
        /// <param name="dimension">The dimension to process along.</param>
        /// <param name="keepdim">1 if the reduction dimension should be kept, 0 otherwise.</param>
        public <#=tname#>Tensor Norm (<#=ttype#> value,  int dimension, int keepdim)
        {
            var result = new <#=tname#>Tensor();
            TH<#=tname#>Tensor_norm (result.handle, this.handle, value, dimension, keepdim);
            return result;
        }

        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_renorm (HType result, HType self, <#=ttype#> value,  int dimension, <#=ttype#> maxnorm);

        /// <summary>
        ///   Compute the renorm of all tensor elements along the given dimension. 
        /// </summary>
        /// <param name="value"></param>
        /// <param name="dimension">The dimension to process along.</param>
        /// <param name="maxnorm"></param>
        public <#=tname#>Tensor Renorm (<#=ttype#> value,  int dimension, <#=ttype#> maxnorm)
        {
            var result = new <#=tname#>Tensor();
            TH<#=tname#>Tensor_renorm (result.handle, this.handle, value, dimension, maxnorm);
            return result;
        }

        [DllImport ("caffe2")]
        extern static <#=accreal#> TH<#=tname#>Tensor_dist (HType a, HType b, <#=ttype#> value);

        /// <summary>
        ///   Compute the dist of all tensor elements along the given dimension. 
        /// </summary>
        /// <param name="other">The other tensor.</param>
        /// <param name="value"></param>
        public <#=accreal#> Dist (<#=tname#>Tensor other, <#=ttype#> value)
        {
            if (other == null)
                throw new ArgumentNullException (nameof (other));
            return TH<#=tname#>Tensor_dist (this.handle, other.handle, value);
        }

        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_histc (HType hist, HType self, long nbins, <#=ttype#> minvalue, <#=ttype#> maxvalue);

        /// <summary>
        ///   Create a histogram of all tensor elements. 
        /// </summary>
        /// <param name="nbins">The number of bins in the output histogram.</param>
        /// <param name="minvalue">Only consider values equal to or greater than this.</param>
        /// <param name="maxvalue">Only consider values equal to or less than this.</param>
        public <#=tname#>Tensor Histc (long nbins, <#=ttype#> minvalue, <#=ttype#> maxvalue)
        {
            var result = new <#=tname#>Tensor();
            TH<#=tname#>Tensor_histc (result.handle, this.handle, nbins, minvalue, maxvalue);
            return result;
        }

        [DllImport ("caffe2")]
        extern static void TH<#=tname#>Tensor_bhistc (HType hist, HType self, long nbins, <#=ttype#> minvalue, <#=ttype#> maxvalue);

        /// <summary>
        ///   Create a histogram of all tensor elements. 
        /// </summary>
        /// <param name="nbins">The number of bins in the output histogram.</param>
        /// <param name="minvalue">Only consider values equal to or greater than this.</param>
        /// <param name="maxvalue">Only consider values equal to or less than this.</param>
        public <#=tname#>Tensor BHistc (long nbins, <#=ttype#> minvalue, <#=ttype#> maxvalue)
        {
            var result = new <#=tname#>Tensor();
            TH<#=tname#>Tensor_bhistc (result.handle, this.handle, nbins, minvalue, maxvalue);
            return result;
        }

        [DllImport ("caffe2")]
        extern static <#=accreal#> TH<#=tname#>Tensor_meanall (HType self);

        /// <summary>
        ///   Compute the mean of all tensor elements. 
        /// </summary>
        public <#=accreal#> MeanAll ()
        {
            return TH<#=tname#>Tensor_meanall (this.handle);
        }

        [DllImport ("caffe2")]
        extern static <#=accreal#> TH<#=tname#>Tensor_varall (HType self, int biased);

        /// <summary>
        ///   Compute the variance of all tensor elements. 
        /// </summary>
        /// <param name="biased"></param>
        public <#=accreal#> VarAll (int biased)
        {
            return TH<#=tname#>Tensor_varall (this.handle, biased);
        }

        [DllImport ("caffe2")]
        extern static <#=accreal#> TH<#=tname#>Tensor_stdall (HType self, int biased);

        /// <summary>
        ///   Compute the standard deviation of all tensor elements. 
        /// </summary>
        /// <param name="biased"></param>
        public <#=accreal#> StdAll (int biased)
        {
            return TH<#=tname#>Tensor_stdall (this.handle, biased);
        }

        [DllImport ("caffe2")]
        extern static <#=accreal#> TH<#=tname#>Tensor_normall (HType self, <#=ttype#> value);

        /// <summary>
        ///   Compute the norm of all tensor elements. 
        /// </summary>
        /// <param name="value"></param>
        public <#=accreal#> NormAll (<#=ttype#> value)
        {
            return TH<#=tname#>Tensor_normall (this.handle, value);
        }

        [DllImport ("caffe2")]
        extern static void TH<#=tname#>dirichlet_grad (HType self, HType x, HType alpha, HType total);
        
        /// <summary>
        ///    DirichletGrad
        /// </summary>
        /// <param name="alpha"></param>
        /// <param name="total"></param>
        public <#=tname#>Tensor DirichletGrad (<#=tname#>Tensor alpha, <#=tname#>Tensor total)
        {
            var result = new <#=tname#>Tensor();
            TH<#=tname#>dirichlet_grad (result.handle, this.handle, alpha.handle, total.handle);
            return result;
        }
<#          } /* if (isFloat) */ #>     
    }
<#
}
#>
}